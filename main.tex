\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsthm, graphicx, pgfplots, tikz, forest}
\usepackage{lmodern} 
\usepackage[german]{babel}  
\usepackage{csquotes} 
\usepackage[margin=2.5cm]{geometry}

\pgfplotsset{compat=1.18}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Korollar}


\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\theoremstyle{remark}
\newtheorem*{remark}{Bemerkung}

\forestset{
  fft tree/.style={
    for tree={
      align=center,
      parent anchor=south,
      child anchor=north,
      edge={thick},
      l sep=10mm,
      s sep=2mm,
      inner sep=1pt,
      rounded corners=2pt,
      draw,
      minimum width=16mm,
      font=\scriptsize
    }
  }
}

\title{Fourier-Methoden: Theorie und Anwendungen}
\author{Felix Wager}
\date{\today}

\begin{document}

\maketitle

\renewcommand{\contentsname}{Inhaltsverzeichnis}
\tableofcontents
\newpage


\section{Abstract}

\section{Einleitung}
\subsection{Motivation}
Warum Fourier-Methoden heute so wichtig sind.
\subsection{Zielsetzung der Arbeit}
\subsection{Aufbau der Arbeit}

\section{Mathematische Grundlagen}
\subsection{Komplexe Zahlen und die Eulerformel}
Um sich die Arbeit mit Fourier Transformationen, Reihen und sonstigem erheblich zu erleichtern ist es sehr sinnvoll mit komplexen Zahlen zu arbeiten. Doch was sind komplexe Zahlen? 
Komplexe Zahlen sind prinzipiell nichts anderes, als eine Erweiterung der Menge der Reellen Zahlen, welche es ermöglicht die Wurzel von negativen Zahlen zu ziehen. Dafür wird die Wurzel von $-1$ als die imaginäre Einheit $i$ definiert. Mathematisch korrekt sieht das wie folgt aus:
$$i^2 := -1$$
Die Menge der komplexen Zahlen wird mit dem Symbol $\mathbb{C}$ abgekürzt. Eine typische komplexe Zahl hat in der algebraischen Schreibweise die Form:
$$ z = a + ib \quad \text{mit} \quad a,b \in \mathbb{R} $$
$a$ ist hierbei der Realteil $\Re(z)$ und $b$ der Imaginärteil $\Im(z)$ von $z$. \vspace{1em}

Um mit komplexen Zahlen bei Fourier Reihen zu arbeiten, benötigt man auch ein paar Rechenoperationen. Die wichtigsten beiden sind hier der Betrag und das komplex konjugierte einer komplexen Zahl. Eine komplexe Zahl lässt sich auch als Vektor im $\mathbb{R}^2$ betrachtet, so ist dann der Betrag als euklidische Norm dieses Vektors definiert. 
$$\vert{z}\vert := \|z\| = \sqrt{ a^2 + b^2}$$
Bedeutet in einem Koordinatensystem, bei dem der Real- und Imaginärteil einer Zahl auf den x- und y-Achsen festgehalten wird, ist der Betrag die Länge vom Ursprung bis zum Punkt im Koordinatensystem dieser Zahl. 
Und das komplex konjugierte einer Zahl ist eine Abbildung, welche lediglich den Imaginärteil mit $-1$ multipliziert:

$$\bar{}\;:\mathbb{C}\;\to\mathbb{C},\; z = x+iy \mapsto \bar{z} := x-iy$$

Mithilfe von komplexen Zahlen und den Taylorreihen von Sinus, Cosinus und der Exponentialfunktion $e^x$ kann man nun die Eulerformel herleiten. 

% $$e^{ix} = \cos{x} + i\sin{x}$$

Wenn man den Betrag dieses Ausdrucks bildet, so fällt auf, dass hier das Ergebnis, unabhängig von $x$, 1 ist. Dies bedeutet, dass $e^{ix}$ als ein gegen den Uhrzeigersinn rotierender Vektor, für steigende Werte für $x$, gesehen werden kann. Im vorher genannten Koordinatensystem, welches man auch die Gaußsche Zahlenebene nennt, sieht das so aus:
\begin{center}
\includegraphics[scale=0.75]{eulerformel.jpg}
\end{center}

\subsection{Das Skalarprodukt von Funktionen und Orthonormalsysteme}
Des Weiteren spielen Orthonormalsysteme eine große Rolle, wenn man sich mit der Fourier Analyse beschäftigt. 
Allgemein lässt sich sagen, dass ein Orthonormalsystem eine Menge von Vektoren oder Funktionen, aus einem Vektorraum mit Skalarprodukt, 
sind, welche sowohl orthogonal zueinander, aber auch normiert zu sich selbst sind. 
Orthogonal sind sie, wenn das Skalarprodukt zweier unterschiedlicher Vektoren 0 ergibt und normiert, wenn das Skalarprodukt eines Vektors mit sich selbst 1 ergibt.
Für alle Vektoren $v_n$ im $\mathbb{R}^n$ muss also folgendes gelten, damit die Menge der Vektoren ein Orthonormalsystem bildet: 
$$\text{1. Orthogonalität: } \langle v_i, v_j\rangle = 0 \quad \forall \:i \neq j $$
$$\text{2. Normiertheit: } \langle v_i, v_j\rangle = \sum_{i=1}^{n}v_i^2 = \|v_i\|^2 = 1 \quad \text{mit} \: i = j$$
$$\left( \text{Skalarprodukt: } \langle v, w\rangle := \sum_{i = 1}^{n}v_i * w_i\right)$$
Hier sieht man auch, dass das Skalarprodukt eines Vektors mit sich selbst, das gleiche 
ist wie die quadrierte euklidische Norm des Vektors, wodurch der Begriff der Normiertheit 
anschaulicher wird. Wie schon erwähnt lassen sich diese Eigenschaften auch auf Funktionen anwenden. 
Hierfür definiert man die Normiertheit und die Orthogonalität auch, exakt gleich wie bei Vektoren, über das Skalarprodukt. Das Skalarprodukt für zwei Funktionen ist wie folgt definiert:
$$\langle v, w \rangle := \int_a^bv{(x)*w(x)dx} \quad \text{für} \: v,w : [a,b] \to \mathbb{R} $$
Falls eine Menge von Funktionen Orthogonalität und Normiertheit erfüllt, ist diese Menge auch ein Orthogonalsystem. 
Anschaulich kann man sich die Funktionen v(x) und w(x) noch als zwei Vektoren mit unendlich 
vielen Dimensionen vorstellen, wobei der x Wert angibt in welcher Dimension man sich befindet. 
Da das Skalarprodukt die jeweiligen Dimensionen von Vektoren multipliziert und diese 
schließlich aufsummiert, macht es Sinn, dass man bei Funktionen ähnlich vorgeht. 
So lässt sich also die Erweiterung der Summe zum Integral erklären.  Die Formel für die 
Norm von Funktionen $\left( \|f\| = \sqrt{\int_a^b{\vert f(x)\vert^2 dx}} \right)$ ergibt sich, wenn man das für Funktionen definierte Skalarprodukt 
ähnlich wie bei Vektoren auf die Funktion selbst anwendet. Im komplexen Fall wird das Skalarprodukt leicht angepasst, 
indem der zweite Faktor komplex konjugiert wird:
$$\langle v,w \rangle := \int_a^b{v(x)*\overline{w(x)}dx} \quad \text{für} \: v,w : [a,b] \to \mathbb{C}$$

\subsection{Die Fourierreihe}
Der erste große Schritt, um die Fourier Transformation herzuleiten, ist die Fourier Reihe. 
Eine Reihe selbst ist in der Mathematik ist ein Begriff für eine unendliche Summe von Termen. 
Die Fourier Reihe ist hierbei eine besondere Reihe. Ihr Sinn ist es periodische Funktionen 
mithilfe von Sinus- und Kosinustermen zu approximieren.  Joseph Fourier hat in seinem Werk 
„Théorie analytique de la chaleur“ schließlich auch beweisen, dass jede periodische Funktion 
auf diese Weise dargestellt werden kann. Die Approximation selbst geschieht durch 
trigonometrische Polynome, mit welchen man später die Fourierreihe einer Funktion bildet. 
Ein trigonometrisches Polynom ist hier eine Funktion der Form: 
$$p(x) = a_0 + \sum_{k=1}^n{a_k \cos(kx) + b_k \sin(kx)}  \quad a_k,b_k \in \mathbb{R}$$
Ziel ist es nun die Faktoren $a_k$ und $b_k$ in Abhängigkeit zur anzunähernden Funktion zu 
bestimmen. Denn durch die Zählervariable k, welche die Periodenlänge der Sinus- und 
Kosinusterme bestimmt, kann man durch die Faktoren $a_k$ und $b_k$ festlegen wie dominant 
die Anteile der Sinus und Kosinusterme, mit der jeweiligen Periodenlänge, in der zu 
approximierende Funktion sind. Um die Berechnung der Faktoren kompakter zu gestalten, 
kann man mit dem Zusammenhang $2\cos{x} = e^{ix} -e^{-ix}$ und $2i\sin{x} = e^{ix}+e^{-ix}$, 
einer Umstellung der Eulerformel, nun das trigonometrische Polynom zu dem komplexen 
trigonometrischen Polynom zusammenfassen: 
$$p(x) = \sum_{k=-n}^n{c_k \, e^{ikx}} \quad \text{für geeignete} \: c_k \in \mathbb{C}$$
Um jetzt den komplexen Faktor $c_k$, zunächst für $2\pi$ periodische Funktionen, 
zu berechnen, verwendet man ein Orthonormalsystem, welches aus den Funktionen $\varphi_n(x)$ besteht:
$$\phi_n(x):[-\pi,\pi] \to \mathbb{C}, \quad \phi_n(x) = \frac{1}{\sqrt{2\pi}} \, e^{inx} \quad \text{mit} \: n\in \mathbb{Z}$$
Dass die Menge an Funktionen $\phi_n$ ein Orthonormalsystem ist, habe 
ich im Anhang gezeigt (Beweis A. 1). Um endlich $c_k$ zu berechnen, setzt man zunächst 
die zu approximierende Funktion $f$, mit der Periodizität $2\pi$, mit dem 
trigonometrischen Polynom gleich und schränkt sie zudem ein: 
$$f:[-\pi,\pi]\to \mathbb{C},\quad f(x) = \sqrt{2\pi} * \sum_{k = -n}^n{c_k\phi_k(x)} $$
Anschließend bildet man das Skalarprodukt von $f$ und $\phi_m$, was möglich ist, da 
$f$ auf der Definitionsbereich von $f$ und $\phi_m$ gleich ist. 
$$\langle f, \phi_m \rangle = \int_{-\pi}^\pi {f(x) \overline{\phi_m(x)}dx} = \int_{-\pi}^\pi{\sqrt{2\pi}\sum_{k = -n}^n{c_k\phi_k(x)\overline{\phi_m(x)}}dx}$$
Da Integral und Summe beide linear sind, darf man die Summe mit dem Integral vertauschen. 
Zudem hängt $c_k$ nicht von $x$ ab, wodurch der Faktor $c_k$ für das Integral eine Konstante ist. 
Nach einer Abwandlung des Distributivgesetzes darf er somit herausgezogen werden. Man erhält 
also diesen Ausdruck: 
$$\int_{-\pi}^\pi{f(x)\overline{\phi_m(x)} dx} = \sqrt{2\pi}\sum_{k=-n}^{n}{c_k\int_{-\pi}^\pi{\phi_k(x) \overline{\phi_m(x)} dx}}$$
Aufgrund dessen, dass die Menge der Funktionen $\phi_m$ ein Orthonormalsystem ist, ist jeder Summand, außer $k = m$, 0. Durch die Normiertheit des Orthonormalsystems bleibt übrig:
$$c_m = \frac{1}{\sqrt{2\pi}}\int_{-\pi}^\pi{f(x)\overline{\phi_m(x)}dx} = \frac{1}{2\pi}\int_{-\pi}^\pi{f(x)e^{imx}dx}$$ 

Jetzt ist es möglich mit dieser Formel und dem komplexen trigonometrischem Polynom eine 
$2\pi$ periodische Funktion zu approximieren. Jedoch wäre es hilfreich, wenn dies für alle 
Perioden möglich wäre. Um auch Funktionen mit einer Periodizität von $2L$ annähern zu können, 
muss man den Faktor $c_k$ und das komplexe trigonometrische Polynom auf einer Periodizität von $2L$ ausweiten. 
Damit das trigonometrische Polynom $2L$ periodisch wird muss folgendes gelten: 
$$e^{i\omega x} = e^{i\omega(x+2L)}$$
$\omega$ gilt es dabei herauszufinden, damit das trigonometrische Polynom $2L$ periodisch wird:
$$e^{i\omega x} = e^{i\omega(x+2L)} \Leftrightarrow e^{i\omega 2L} = 1 \Leftrightarrow \omega 2L = 2\pi k \Leftrightarrow \omega_k = \frac{k\pi}{L}$$
Das neue trigonometrische Polynom sieht also so aus:
$$\sum_{k=-n}^n{c_k e^{i\omega_kx}} \Leftrightarrow \sum_{k=-n}^n{c_k e^{i\frac{k\pi}{L}x}}$$
Um $c_k$ zu berechen, nimmt man sich eine $2L$ periodische Funktion $f$ und definiert sich eine $2\pi$ periodische 
Hilfsfunktion $g$ in Abhängigkeit von $f$ wie folgt:
$$g(t) := f\left(\frac{L}{\pi}t\right) $$
Da $g$ eine $2\pi$ periodische Funktion ist, kann man mit der hergeleiteten Formel $c_k$ 
von $g$ berechnen. Um die Formel für $2L$ periodische Funktionen zu erhalten, ist das 
Ziel die Formel über $g$ auf $f$ auszuweiten. Das funktioniert über die Substitutionsregel 
bei Integralen. Um sie anzuwenden, führen wir die Ableitung der inneren Funktion von $f$, 
also $\frac{L}{\pi}$ in Form einer $1$ ein und erhalten die Formel für $c_k$, für die 
Periodizität $2L$: 
$$c_k = \frac{1}{2\pi} \int_{-\pi}^\pi{g(t)e^{-ikt}dt} \Leftrightarrow c_k = \frac{1}{2\pi}*\frac{\pi}{L} \int_{-\pi}^{\pi}{\frac{L}{\pi}f\left(\frac{L}{\pi}t\right)e^{-i\omega_kt} dt}$$
Wendet man jetzt die Substitutionsregel an, erhält man: 
$$c_k = \frac{1}{2L}\int_{-L}^{L}{f(x)e^{-i\omega_kx}dx} = \frac{1}{2L}\int_{-L}^{L}{f(x)e^{-i\frac{k\pi}{L}x}dx}$$

\subsection{Von der Fourierreihe zur Fouriertranformation}
Die Fourierreihe erlaubt es uns, periodische Signale als Summe von Sinus- und Kosinusfunktionen oder komplexen Exponentialfunktionen darzustellen. Doch viele Signale in der Praxis sind nicht-periodisch. Um auch diese Signale in ihre Frequenzanteile zerlegen zu können, verallgemeinern wir das Konzept der Fourierreihe zur Fouriertransformation. Mit der Fouriertransformation werden wir so eine Funktion erhalten, welche uns sagen wird wie groß der Anteil einer Frequenz oder Periodenlänge in einem Signal ist. Dazu nehmen wir die Fourierreihe einer Funktion $f$ mit der Periode $2L$ und der Frequenz $\omega_k$: 
$$f(x) = \sum_{k = -\infty}^{\infty}{c_k e^{i\omega_k x} }, \quad c_k = \frac{1}{2L}\int_{-L}^L{f(x) e^{-i\omega_k x} dx}$$
Dazu definieren wir eine Hilfsfunktion $F(\xi)$: 
$$F:\mathbb{K} \to \mathbb{C}, \quad F(\xi) = \int_{-L}^{L}{f(x) e^{-i \xi x} dx}$$
damit gilt
$$ c_k = \frac{1}{2L} F(\omega_k)$$
Setzt man den neu gewonnen Ausdruck für $c_k$ in die Fourierreihe ein, so erhält man 
$$ f(x) = \sum_{n = -\infty}^{\infty}{F(\omega) e^{i\omega x}}$$
Anschließend bildet man $\Delta \omega$ aus $\omega_k$:
$$\omega_k = k \frac{\pi}{L} \Rightarrow \Delta \omega = \frac{\pi}{L} \Rightarrow \frac{1}{2L} = \frac{\Delta \omega} {2\pi}$$
Und setzt die Gleichung auch in die Fourierreihe ein: 
$$\frac{1}{2\pi} \sum_{k=-\infty}^{\infty}{F(\omega_k) e^{i \omega_k x} \Delta \omega}$$
Dies ist eine Riemann Summe. Lässt man nun $L \to \infty$ laufen, erhält man ein Integral, welches die inverse Fouriertransformation ist:
$$\lim_{L\to\infty} {\frac{1}{2\pi}\sum_{n = -\infty}^\infty{F(\omega_k) e^{i \omega_k x}\Delta \omega}} = \frac {1}{2\pi} \int_{-\infty}^{\infty}{F(\omega)e^{i \omega x} d\omega}$$
Die Funktion $F(\omega)$ selbst ist die Fouriertransformation von $f$:
$$F(\omega) = \int_{-\infty}^{\infty}{f(x) e^{-i\omega x} dx}$$

Man kann das Integral in der Fouriertransformation am besten verstehen, wenn man es 
als eine Art Durchschnitt betrachtet. Ähnlich wie beim Berechnen eines Mittelwerts 
summiert das Integral nicht nur eine endliche Anzahl von Werten auf, sondern unendlich viele, 
unendlich kleine Beiträge von $f(x)$. Im Integral steht dabei das Produkt $f(x) \cdot e^{-i\omega x}$.
Dieses Produkt misst, wie stark die Frequenz $\omega$ in $f(x)$ enthalten ist:
\begin{itemize}
    \item Ist der Anteil der Frequenz $\omega$ in $f(x)$ hoch, dann verstärkt $e^{i\omega_kx}$ den Wert der Funktion $f(x)$
    im Integral konstruktiv und $F(\omega)$ wird groß.
    \item Enthält $f(x)$ diese Frequenz nicht, heben sich die positiven und negativen Anteile 
    im Integral weitgehend auf und $F(\omega)$ wird klein.
\end{itemize}
So zeigt die Fouriertransformation, wie groß der Anteil jeder einzelnen Frequenz $\omega$ 
in der Funktion $f$ ist.

\subsection{Die Foureirtransformation in der Praxis: Die DFT}
In der Praxis arbeitet man selten mit kontinuierlichen Funktionen, sondern mit diskreten Messwerten, zum Beispiel bei Audiosignalen oder digitalen Bildern. Um diese Signale in ihre Frequenzanteile zu zerlegen, verwendet man die diskrete Fouriertransformation (DFT).
Formell lässt sich die DFT für eine endliche Folge von N Messwerten
$$x_0, x_1,..., x_{N-1}$$
durch die folgende Formel darstellen:
$$X_k = \sum_{j = 0}^{N-1}{x_n e^{-i2\pi \frac{kj}{N}}} \quad \text{mit } k\in[0, N-1]$$
Anzumerken ist aber noch, dass es eine Besonderheit gibt. Wenn das Eingangssignal reell ist, 
liefert die DFT zwar N Koeffizienten, jedoch sind die Frequenzen oberhalb von N/2 wegen des 
Nyquist-Theorems lediglich Spiegelungen der tieferen Frequenzen und enthalten keine neuen 
Informationen. Warum das so ist, werde ich hier nicht näher eingehen. Wie man die Formel für 
die DFT herleitet, erkläre ich im nächsten Kapitel.

\subsection{Die Foureirtransformation in der Praxis: Die FFT}
Obwohl die DFT so in der Praxis anwendbar ist, ist sie heutzutage in fast keinem Programm oder 
Algorithmus zu finden. Denn will man eine Funktion oder Signal mit $N$ Werten komplett 
transformieren, dann muss man für $N$ verschiedene Frequenzen den Wert über die obere Formel 
berechnen. Also sind es insgesamt $N^2$ Berechnungen, die man durchführen muss. In der Informatik 
spricht man für den Abschnitt der DFT in einem Programm von einer Laufzeit von:   $O(N^2)$

Im Jahre 1965 aber, entdeckte James W. Cooley und John W. Tukey eine neue Art die DFT zu 
berechnen, was die Laufzeit auf $O(N\log N)$ verringerte. Somit konnte man die DFT erheblich 
schneller berechnen. Daher kommt auch der Name FFT für den neuen Algorithmus, was für Fast Fourier 
Transform, also schnelle Fouriertransformation, steht. Um die Umformung gut zu sehen, kann man die 
diskrete Fouriertransformation etwas umschreiben. Dafür definiere ich die Folge $(\omega_n)_{n\in\mathbb{N}}$ 
wie folgt:
$$\omega_n := e^{-2\pi i /n}$$
Schreibt man jetzt die Werte der Ausgangsfunktion $f$ als Vektor, kann man aufgrund der Struktur 
der Matrixmultiplikation, diesen Vektor mit einer besonderen Matrix multiplizieren und erhält das 
Ergebnis der Transformation auch in Form eines Vektors derselben Länge, mit den Werten $\hat{f}$. 
\[
\begin{bmatrix}
\hat{f_0}\\
\hat{f_1}\\
\hat{f_2}\\
\vdots \\
\hat{f_n}\\
\end{bmatrix}
=
\begin{bmatrix}
1 & 1 & 1 & \cdots & 1\\
1 & \omega_n & \omega_n^2 & \cdots & \omega_n^{n-1} \\
1 & \omega_n^2 & \omega_n^4 & \cdots & \omega_n^{2(n-1)}\\
\vdots & \vdots & \vdots & \ddots & \vdots \\
1 & \omega_n^{n-1} & \omega_n^{2(n-1)} & \cdots & \omega_n^{(n-1)^2}\\
\end{bmatrix}
 \cdot
\begin{bmatrix}
f_0\\
f_1\\
f_2\\
\vdots\\
f_n
\end{bmatrix}
\left(
= 
\begin{bmatrix}
\omega_n^{0 \cdot 0} & \omega_n^{0 \cdot 1} & \cdots & \omega_n^{0 \cdot (n-1)}\\
\omega_n^{1 \cdot 0} & \omega_n^{1 \cdot 1} &  \cdots & \omega_n^{1 \cdot (n-1)} \\
\omega_n^{2 \cdot 0} & \omega_n^{2 \cdot 1} &  \cdots & \omega_n^{2 \cdot (n-1)}\\
\vdots & \vdots & \ddots & \vdots \\
\omega_n^{(n-1) \cdot 0} & \omega_n^{(n-1) \cdot 1} & \cdots & \omega_n^{(n-1)^2}\\
\end{bmatrix}
\cdot
\begin{bmatrix}
f_0\\
f_1\\
f_2\\
\vdots\\
f_n
\end{bmatrix}
\right)
\]
Jeder Eintrag im Ergebnisvektor entsteht, indem man die Zahlen in der Zeile der Matrix 
mit den Zahlen im Vektor multipliziert und die Produkte zusammenzählt. Deshalb muss 
jeder Eintrag der Matrix aus $\omega_n$ noch mit $k$, der die Frequenz bestimmt, und 
der Zählvariable $j$, die über die Zeilen läuft, als Exponent potenziert werden.

Was Cooley und Tukey herausgefunden haben ist, dass man diesen Ausdruck wie so umschreiben 
kann:

\[\hat{f} = F_N \cdot f = 
\begin{bmatrix}
I_{N/2} & D_{N/2} \\
I_{N/2} & -D_{N/2}
\end{bmatrix}
\cdot 
\begin{bmatrix}
F_{N/2} & 0 \\
0 & F_{N/2} \\ 
\end{bmatrix}
\cdot 
\begin{bmatrix}
f_{gerade} \\
f_{ungerade}
\end{bmatrix}
\]
$F$ ist die DFT-Matrix, mit der der ursprüngliche Wertevektor $f$ multipliziert wurde. 
$I_N$ ist die Einheitsmatrix: Alle Einträge außerhalb der Diagonale sind $0$, auf der 
Diagonale stehen $1$, von links oben nach rechts unten. $D_N$ ist ebenfalls eine Diagonalmatrix 
wie $I_N$, jedoch bestehen die Diagonaleinträge aus $\omega_N^k$, wobei $k$ von $0$ bis $N-1$ 
läuft. Der Index der Matrizen gibt jeweils die Anzahl der Zeilen und Spalten an. $f$ wurde den Indizes nach aufgeteilt. 

Wichtig ist, diese Formel funktioniert nur, wenn die Anzahl der Werte der Ausgangsfunktion 
eine Zweierpotenz ist. Zumal das genau der Grund ist, warum die Umstellung es überhaupt schafft die Laufzeit 
so drastisch zu reduzieren. Das was diese Formel ausmacht sind eigentlich nur die letzen beiden 
Faktoren des Produkts. Denn multipliziert man diese Faktoren miteinander, dann fällt auf, dass 
man diesen Ausdruck erhält:
\[
\begin{bmatrix}
F_{N/2} \cdot f_{gerade} & 0 \\
0 & F_{N/2} \cdot f_{ungerade} 
\end{bmatrix}
\]

Auffällig ist jetzt, dass man zwei mal das Anfangsproblem, in halber Größe erhält. Man könnte 
zunächst denken, dies mache keinen Unterschied, aber dadurch dass die Berechnung der komplette Matrix, einen
Aufwand von $O(N^2)$ erfordert, reduziert man mit jeder Anwendung der Formel die Laufzeit für 
die Berechnung von $F_{N/2} \cdot f$ auf $O((N/2)^2)$. Wendet man diese Formel rekursiv, also 
immer wieder auf sich selbst, an, bis man Matrizen mit einer Größe von 1 oder 2 erhält, so 
schafft man es, durch ein zeitsparendes zusammenfügen, die Laufzeit der Berechnung auf 
$O(N\log N)$ zu kürzen. Die Struktur einer FFT mit 8 Werten, kann man auch so darstellen:
\\ \\ \\
\begin{forest}
  fft tree
  [
    {\(F_8\cdot f_8\)\\(ganze DFT)}
    [
      {\(F_4\cdot f_4\)\\(gerade)}
      [
        {\(F_2\cdot f_2\)\\(gerade)}
        [\(F_1\cdot f_1\)\\(gerade)]
        [\(F_1\cdot f_1\)\\(ungerade)]
      ]
      [
        {\(F_2\cdot f_2\)\\(ungerade)}
        [\(F_1\cdot f_1\)\\(gerade)]
        [\(F_1\cdot f_1\)\\(ungerade)]
      ]
    ]
    [
      {\(F_4\cdot f_4\)\\(ungerade)}
      [
        {\(F_2\cdot f_2\)\\(gerade)}
        [\(F_1\cdot f_1\)\\(gerade)]
        [\(F_1\cdot f_1\)\\(ungerade)]
      ]
      [
        {\(F_2\cdot f_2\)\\(ungerade)}
        [\(F_1\cdot f_1\)\\(gerade)]
        [\(F_1\cdot f_1\)\\(ungerade)]
      ]
    ]
  ]
\end{forest}
\\ \\ \\ 
In meinem Programm, zu welchem ich im nächsten Kapitel komme, mit welchem ich eine Audiospur 
aufnehme und verarbeite, nutze ich eine auf meinem Gerät eine Samplerate von 44800. Bedeutet 
ich nehme pro Sekunde 44800 Datenpunkte auf. Wenn man nun die Laufzeit einer DFT und einer FFT 
grob skizziert, sieht man, dass bei der Verarbeitung eines Signals, mit nur einer Sekunde, bei 
meinem Programm die DFT mehr als doppelt so lang dauert, wie die FFT.  

\begin{figure}[!h]
\centering
\begin{tikzpicture}
  \begin{axis}[
    width=12cm, height=8cm,
    xlabel={Samples $N$},
    ylabel={Operationen},
    %title={Vergleich der Laufzeit von DFT und FFT},
    axis lines=left,
    clip=false,
    xmin=0, xmax=45000,
    ymode=log,
    legend style={at={(0.02,0.98)},anchor=north west},
    ytick style={draw=none} % nur Striche entfernen
  ]
    % DFT: O(N^2)
    \addplot[blue, thick, samples=200, domain=100:44800] {x^2};
    \addlegendentry{DFT O($N^2$)}

    % FFT: O(N log N)
    \addplot[red, thick, samples=200, domain=100:44800] {x*ln(x)/ln(2)};
    \addlegendentry{FFT O($N \log_2 N$)}
  \end{axis}
\end{tikzpicture}
%\caption{Vergleich der Laufzeit von DFT und FFT für Sample-Größen $N$ bis 44{,}800}
\end{figure}



\section{Von der Theorie zu Praxis: Eigenentwicklung eines Audioanalyzers mit C++}
Nachdem im vorherigen Kapitel die mathematischen Grundlagen der Fouriertransformation und 
ihrer diskreten Varianten vorgestellt wurden, möchte ich nun zeigen, wie ich diese Konzepte 
praktisch umgesetzt habe. Angefangen hat alles mit der Idee einen eigenen Audioanalyzer zu 
programmieren. Dieser soll live ein Audiosignal aufnehmen, dieses Visualisieren und anschließend 
die Frequenzanteile, die in dem Signal enthalten sind, anzeigen. Somit könnte ich mithilfe 
meines eigenen Programms Musik genauer unter die Lupe nehmen, die Funktion der Fouriertransformation 
so manipulieren, dass Rauschen unterdrückt wird, Töne von Tieren oder Instrumenten erkennen 
oder auch Raumresonanzen sichtbar machen. Als ich mit dem Programmieren begann und alles 
zur Liveaufnahme eines Audiosignals implementiert hatte, stieß ich auf eine erste Schwierigkeit. 
Mein Problem war der Übergang von der Theorie der Fouriertransformation zur Praxis. Denn 
ich hatte ein Signal in Form einer Liste von Zahlen, wodurch die normale Formel für die 
Fouriertransformation durch das Integral nicht anwendbar war. Da ich zum damaligen Zeitpunkt 
die diskrete Fouriertransformation nicht kannte, versuchte ich eigenständig eine Approximation 
der Formel für endliche Werte zu finden. Im folgenden Abschnitt zeige ich also, wie ich 
eigenständig die DFT mit einer minimalen Abweichung hergeleitet habe.
\subsection{Eigenständige Herleitung der DFT}
Da ich, wie zuvor erwähnt, die DFT noch nicht kannte, versuchte ich zunächst aus den Punkten, 
also die Daten der Audioaufnahme, eine Funktion zu erstellen, auf welche die Formel anwendbar 
ist. Ein Hauptkriterium, um die Formel zu realisieren ist, dass die Funktion integrierbar ist. 
Natürlich kann man ausgehend von den Punkten viele Rechtecke nutzen und diese als Approximation 
für die Fläche des Integrals zu benutzen. Das sähe so aus:

\begin{figure}[h!]
\centering
\begin{tikzpicture}[>=stealth]

% Achsen
\draw[->] (-0.5,0) -- (15.5,0) node[right] {$n$};
\draw[->] (0,-2.5) -- (0,2.5) node[above] {$f(n)$};

% Winkel pro Einheit (in Grad) sodass 1.5 Perioden auf [0,14] liegen
\pgfmathsetmacro{\degPerUnit}{180*3/14} % = 38.5714286...

% Diskrete Punkte f(n) (aus der Sinusfunktion)
\foreach \x in {0,...,14} {
    \pgfmathsetmacro{\yy}{2*sin(\degPerUnit*\x)} % sin erwartet hier Grad
    \fill[red] (\x,\yy) circle (2pt);
    \node[red, above, font=\scriptsize] at (\x,\yy) {$f(\pgfmathprintnumber{\x})$};
    \draw[dashed, gray!60] (\x,0) -- (\x,\yy);
}

% Rechteckflächen (linke Riemann-Summe)
\foreach \i in {0,...,13} {
    \pgfmathsetmacro{\y}{2*sin(\degPerUnit*\i)} % Höhe = f(n)
    \fill[blue!20, opacity=0.5] (\i,0) rectangle (\i+1,\y);
}

% (Optional) kontinuierliche Referenz-Sinuskurve mit gleicher Frequenz
\draw[domain=0:14, smooth, samples=300, thin, red!70] plot(\x,{2*sin(\degPerUnit*\x)});

% Beschriftung Rechteckformel
\node at (9,-2.3) {\footnotesize Fläche Rechteck: $A = (x_{n+1}-x_n)\,f(n)$};

\end{tikzpicture}
\end{figure}

Im Prinzip ist dies nichts anders als die Treppenfunktion einer Funktion, wobei man im nicht 
die Ober- oder Untersumme der Funktion nimmt, also $\sup{\{f(x) | x \in I_n\}}$ oder 
$\inf{\{f(x) | x\in I_n\}}$ als obere Grenze der Rechtecke Intervall $I_n = [f(n), f(n+1))$ 
wählt, sondern eine Art Mischung aus beidem. 
\\ \\
Wenn man eine große Menge an Datenpunkten hat und diese sehr nah aneinander liegen, dann ist 
diese Methode eine gute Approximation des tatsächlichen Integrals. Trotzdem habe ich mich dazu entschieden, 
die Punkte durch eine jeweilige stetige Fortsetzung zu verbinden und dann das Integral davon zu 
bilden, um die Approximation noch etwas genauer zu gestalten. Meine stetige Fortsetzng besteht aus 
geraden Linien, welche die Puntkte zu einer stetigen Funktion am Ende verbinden. Bei wenigen Punkten 
wie in meinem Beispiel ist der Unterschied zwischen den zwei Approximationen gut zu erkennen.
\begin{figure}[h!]
\centering
\begin{tikzpicture}[>=stealth]

% Achsen
\draw[->] (-0.5,0) -- (15.5,0) node[right] {$n$};
\draw[->] (0,-2.5) -- (0,2.5) node[above] {$f(n)$};

% Winkel pro Einheit (in Grad) sodass 1.5 Perioden auf [0,14] liegen
\pgfmathsetmacro{\degPerUnit}{180*3/14} % = 38.5714286...

% Diskrete Punkte f(n) (aus der Sinusfunktion)
\foreach \x in {0,...,14} {
    \pgfmathsetmacro{\yy}{2*sin(\degPerUnit*\x)} % sin erwartet hier Grad
    \fill[red] (\x,\yy) circle (2pt);
    \node[red, above, font=\scriptsize] at (\x,\yy) {$f(\pgfmathprintnumber{\x})$};
    \draw[dashed, gray!60] (\x,0) -- (\x,\yy);
}

% Linien zwischen Punkten (Stückweise verbunden)
\draw[thick, blue] (0,{2*sin(0)})
\foreach \x in {1,...,14} {
   -- (\x,{2*sin(\degPerUnit*\x)})
};

% Trapezflächen (je zwei aufeinanderfolgende Punkte)
\foreach \i in {0,...,13} {
    \pgfmathsetmacro{\yone}{2*sin(\degPerUnit*\i)}
    \pgfmathsetmacro{\ytwo}{2*sin(\degPerUnit*(\i+1))}
    \pgfmathsetmacro{\xnext}{\i+1}
    \fill[blue!20, opacity=0.5] (\i,0) -- (\i,\yone) -- (\xnext,\ytwo) -- (\xnext,0) -- cycle;
}

% (Optional) kontinuierliche Referenz-Sinuskurve mit gleicher Frequenz
\draw[domain=0:14, smooth, samples=300, thin, red!70] plot(\x,{2*sin(\degPerUnit*\x)});

% Beschriftung Trapezformel
\node at (9,-2.3) {\footnotesize Fläche Trapez: $A = \tfrac{1}{2} (x_{n+1}-x_n)\,(f(n)+f(n+1))$};

\end{tikzpicture}
\end{figure}
\\ \\ \\ \\ \\ \\ \\
Die Funktionenfolge, die ich dabei als Fortsetzung für die jeweiligen Punkte genutzt habe ist folgende:
$$\left(g_n(x)\right)_{n\in \mathbb{N}_0} = \frac{f(n+1) - f(n)}{n+1 -n } \cdot x + \frac{nf(n+1) - (n+1)f(n)}{n+1 -n} \quad \text{mit } x\in\mathbb{R} $$
Die Nenner der beiden Brüche fallen weg, doch ich habe sie hier da gelassen, damit man sieht, dass 
die Steigung beispielsweise der Differenzenquotient zweier Punkte ist. 
\\ 
Um auch sicherzustellen, dass meine resultierende Funktion wirklich stetig ist, habe ich es bewiesen. 
Da man es bei einem Punkt jeweils von zwei Seiten zeigen muss, dass die Funktion dort stetig ist, habe ich die 
Stetigkeit auf zwei Arten bewiesen. Einmal über das Epsilon-Delta-Kriterium und einmal über die Folgenstetigkeit. 
Die Beweise findet man beide im Anhang (LÜCKE). Da ich die Funktion $a(x)$ bestehend aus den Daten und der Funktionen folge $g_n$ 
aber noch mit dem Faktor $e^{-i\omega x}$ multiplizieren muss, habe ich dazu noch bewiesen, dass dieser Ausdruck stetig ist. 
Dazu musste ich nur beweisen, dass das Produkt aus zwei stetigen Funktionen auch stetig ist. Denn es gibt einen 
Satz aus der komplexen Analysis, welcher besagt, dass eine Komplexe Funktion genau dann stetig ist, 
wenn ihre Real- und Imaginärteile stetig sind. Und da der Sinus und Kosinus stetige Funktionen sind, 
ist lediglich zu zeigen, dass das Produkt zweier stetiger Funktionen stetig ist (Anhang LÜCKE). Bedeutet man könnte 
theoretisch mit einem Stift die Funktion nachzeichnen, ohne diesen abzusetzen. 
\\ \\
Anschließend müsste man noch beweisen, dass wenn man die Funktion $a(x)\cdot e^{-i\omega x}$ auf die gleiche Weise 
fortsetzen kann wie $a(x)$. Das habe ich hier, aber nicht gemacht, da der Beweis sehr ähnlich zum Stetigkeitsbeweis zuvor ist.
Anschließend bleibt noch die tatsächliche Fläche, also das Integral, der neu gebildeten Funktion zu berechnen. 
Dazu habe ich zunächst gezeigt, dass die Funktion $z(x)$, eine Zusammensetzung aus $a(x)$ und $e^{-i\omega x}$,
eine Regelfunktion ist und so auch integrierbar ist. 


\subsection{Berechnung der Koeffizienten}
\subsection{Eigenschaften und Konvergenz}

\section{Von der Reihe zur Fourier-Transformation}
\subsection{Übergang zum Integral}
\subsection{Fourier-Transformation und inverse Transformation}
\subsection{Eigenschaften}
Linearität, Verschiebung, Faltung.

\section{Diskrete Fourier-Transformation (DFT)}
\subsection{Definition und Motivation}
\subsection{Herleitung aus der Fourier-Transformation}
Eigene Herleitung
\subsection{Beweise für die Korrektheit}
\subsection{FFT als effiziente Berechnung}

\section{Eigene Beiträge}
\subsection{Eigene Herleitung der DFT}
\subsection{Beweise}
\subsection{Eigener FFT-Algorithmus in Python}
\subsection{Audio-Programm zur Echtzeit-Visualisierung}

\begin{figure}[h!]
\centering
\begin{tikzpicture}
    \begin{axis}[
    width=\textwidth,
    height=8cm,
    xlabel={Zeit [s]},
    ylabel={Zeit [s]},
    grid=major,
    major grid style={gray!30},
    legend style={at={(0.5,-0.2)}, anchor=north, legend columns=2, font=\small},
    label style={font=\large},
    tick label style={font=\small},
    line width=1pt,
    no markers,
    cycle list={
        {blue},
        {red},
        {brown},
        {black},
        {teal}
        }
        ]
        
        \addplot table[x index=1, y expr=\thisrowno{2}/1000] {fft_bench5.dat};
        \addlegendentry{Rekursive FFT}
        
        \addplot table[x index=1, y expr=\thisrowno{3}/1000] {fft_bench5.dat};
        \addlegendentry{Iterative FFT}
        
        \addplot table[x index=1, y expr=\thisrowno{4}/1000] {fft_bench5.dat};
        \addlegendentry{Iterative FFT auf GPU}
        
        \addplot table[x index=1, y expr=\thisrowno{5}/1000] {fft_bench5.dat};
        \addlegendentry{cuFFT-Bibliothek (GPU)}
        
        \addplot table[x index=1, y expr=\thisrowno{6}/1000] {fft_bench5.dat};
        \addlegendentry{FFTW-Bibliothek (CPU)}
        
        
    \end{axis}
\end{tikzpicture}
\caption{Vergleich der FFT-Methoden anhand der Benchmarks.}
\end{figure}

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            width=\textwidth,
            height=8cm,
            xlabel={Zeit [ms]},
            ylabel={Zeit [ms]},
            grid=major,
            major grid style={gray!30},
            legend style={at={(0.5,-0.2)}, anchor=north, legend columns=2, font=\small},
            label style={font=\large},
            tick label style={font=\small},
            line width=1pt,
            no markers,
            cycle list={
                {blue},
                {red},
                {brown},
                {black},
                {teal}
                }
                ]
                
                \addplot table[x expr=\thisrowno{1}*1000, y index=2] {fft_bench_small.dat};
                \addlegendentry{Rekursive FFT}
                
                \addplot table[x expr=\thisrowno{1}*1000, y index=3] {fft_bench_small.dat};
                \addlegendentry{Iterative FFT}
                
                \addplot table[x expr=\thisrowno{1}*1000, y index=4] {fft_bench_small.dat};
                \addlegendentry{Iterative FFT auf GPU}
                
            \end{axis}
        \end{tikzpicture}
        \caption{Vergleich der FFT-Methoden für die zweite Messreihe.}
    \end{figure}
    
    \begin{figure}[h!]
        \centering
        \begin{tikzpicture}
            \begin{axis}[
                width=\textwidth,
                height=8cm,
                xlabel={Zeit [min]},
                ylabel={Zeit [s]},
                grid=major,
                major grid style={gray!30},
                legend style={at={(0.5,-0.2)}, anchor=north, legend columns=2, font=\small},
                label style={font=\large},
                tick label style={font=\small},
                line width=1pt,
                no markers,
                cycle list={
                    {black},
                    {teal}
                    }
                    ]
                    
                    \addplot table[x expr=\thisrowno{1}/60, y expr=\thisrowno{2}/1000] {fft_bench_big.dat};
                    \addlegendentry{cuFFT-Bibliothek (GPU)}
                    
                    \addplot table[x expr=\thisrowno{1}/60, y expr=\thisrowno{3}/1000] {fft_bench_big.dat};
                    \addlegendentry{FFTW-Bibliothek (CPU)}
                    
                \end{axis}
            \end{tikzpicture}
            \caption{Vergleich der FFT-Methoden für die zweite Messreihe.}
        \end{figure}
        
        \subsection{Bildverarbeitung: Moiré-Muster entfernen mit 2D-FFT}
        
        \section{Anwendungen}
        \subsection{Audio}
        Echtzeitaufnahme und Visualisierung, Tonhöhenerkennung oder Noise Cancelling, Ergebnisse.
        \subsection{Bild}
        Röntgenbild und Moiré-Filterung, Ergebnisse.
        
\section{Anhang}

\subsection{Eigene Beweise}
    \begin{theorem}\label{thm:orthonorm}
        Die Menge $\{\phi_n(x)\}_{n\in\mathbb{Z}}$ mit $\phi_n:[-\pi, \pi] \to \mathbb{C}, \\ \phi_n(x) = \frac{1}{\sqrt{2\pi}}e^{inx}$ bildet ein Orthonormalsystem.
    \end{theorem}
        
    \begin{proof}
        Ich zeige die Orthonormalität in zwei Schritten: 
            
        \textbf{1. Orthogonalität:}  
        Für $m \neq n$ gilt
        $$\langle \phi_n, \phi_m \rangle = \int_{-\pi}^{\pi}{\phi_n(x) \overline{\phi_m(x)}} = \frac{1}{2\pi}\int_{-\pi}^\pi{e^{i(n-m)x}dx}$$
            
        Jetzt definiere ich $l := n-m$
        \[\frac{1}{2\pi}\int_{-\pi}^\pi{e^{i(n-m)x}dx} = \frac{1}{2\pi}\int_{-\pi}^\pi{\cos(lx) + i \sin (lx)} dx\] 
            
        \[= \frac{1}{2\pi l}\left(\int_{-\pi}^\pi{\cos (lx) dx} + i\int_{-\pi}^\pi{ \sin (lx) dx} \right)  = \frac{1}{2\pi l} \left(\sin(lx)\big|_{-l\pi}^{l\pi} - i\cos(lx)\big|_{-l\pi}^{l\pi} \right)\]
            
        \[= \frac{1}{2\pi l} \cdot \left(\sin(l^2\pi) - \sin(-l^2\pi) - i\left(\cos(l^2\pi) - \cos(-l^2\pi)\right)\right) \]
            
        Da $l\in \mathbb{Z}$ ist $l^2 \in \mathbb{Z}$. Ein ganzzahliges Vielfaches von $\pi$
        eingesetzt im Sinus ist zudem immer 0. Denn der Sinus ist eine $2\pi$ periodische Funktion, und da
        sowohl $\sin(0) = 0$, als auch $\sin (\pi) = 0$ ist, ist jedes ganzzahliges Vielfaches von $\pi$ eingesetzt 
        im Sinus 0. Hinzu kommt, dass der Kosinus Achsensymmetrisch bezüglich der Y-Achse ist, also gilt:
        $\cos (x) =  \cos (-x)$. Daraus folgt:
        \[= \frac{1}{2\pi l} \cdot (0 - 0 - i\cdot(\cos(l\pi) - \cos(l\pi))) = \frac{1}{2\pi l} \cdot 0 = 0\]
            
            
        \textbf{2. Normiertheit:}  
        Für $m = n$ gilt
            
        \[\langle \phi_n, \phi_m \rangle = \int_{-\pi}^{\pi} \phi_n(x) \overline{\phi_n(x)} \, dx = \frac{1}{2\pi} \int_{-\pi}^{\pi} e^{i(n -n) x}\, dx = \frac{1}{2\pi} \int_{-\pi}^{\pi} e^{i\cdot0} \, dx\]
            
        \[= \frac{1}{2\pi} \int_{-\pi}^{\pi} 1 \, dx = \frac{1}{2\pi} \cdot x \Big|_{-\pi}^{\pi} = \frac{1}{2\pi} \cdot (\pi-(-\pi)) = 1\]
            
        Damit ist gezeigt, dass $\{\phi_n(x)\}_{n\in\mathbb{Z}}$ ein Orthonormalsystem bildet.
        \end{proof}

\begin{theorem}\label{Stetigkeit Folgenstetigkeit}
  Sei eine Funktion $a : \mathbb{R} \to \mathbb{R}$ definiert als 
  \[
    a(x) = \begin{cases}
      f(x) & \text{für } x \in \mathbb{Z} \\
      f(\lceil x \rceil) - f(\lfloor x \rfloor)\cdot (x - \lfloor x \rfloor) + f(\lfloor x \rfloor) & \text{für } x \notin \mathbb{Z} \:,
    \end{cases}
    \]
    dann ist gilt $\forall$ Folgen $x_n < n$ mit $\lim\limits_{n\to\infty}{x_n} = n \text{ mit } n \in \mathbb{Z}$, 
    dann gilt $f(x_n)
    \xrightarrow[n\to\infty]{} f(n)$
\end{theorem}
\begin{proof}
\begin{equation*}
\begin{aligned}
a(x_n) &= \big(f(\lceil x_n \rceil) - f(\lfloor x_n \rfloor)\big)\cdot (x_n - \lfloor x_n \rfloor) + f(\lfloor x_n \rfloor) \\
&= \big(f(\lfloor x_n \rfloor) - f(\lfloor x_n \rfloor)\big)\cdot (x_n - n) + f(\lfloor x_n \rfloor) \\
&\stackrel{n\to\infty}{=} \big(f(\lceil n \rceil) - f(\lfloor n \rfloor)\big)\cdot (n - n) + f(\lfloor n \rfloor) \\
&= f(n) = a(n)
\end{aligned}
\end{equation*}
Damit ist die Funktion auf den Intervallen $I_n = (n; n+1]$ stetig. 
\end{proof}

\begin{theorem}\label{Stetigkeit}
 Sei $x \in \mathbb{R}$. Sei $\varepsilon > 0$. Wählen wir 
$$
\delta = \frac{\varepsilon}{|f(n+1) - f(n)|} - 2,
$$
dann gilt für alle $x \in \mathbb{R}$ mit $x-n \leq \delta$ und mit $n \in \mathbb{Z}$:
\end{theorem}
\begin{proof}
\begin{align*}
|a(x) - a(n)| 
&= \big| (f(n+1) - f(n)) \cdot (x-n+1) + f(n+1) - f(n) \big| \\[6pt]
&= \big| (f(n+1) - f(n)) - (n+1) \cdot (f(n+1) - f(n)) + f(n+1) - f(n) \big| \\[6pt]
&= \big| 2f(n+1) - 2f(n) - (x-n) \cdot (f(n+1) - f(n)) \big| \\[6pt]
&= \big| 2 \cdot (f(n+1) - f(n)) - (x-n) \cdot (f(n+1) - f(n)) \big| \\[6pt]
&< \big| 2 \cdot (f(n+1) - f(n)) - (x-n) \cdot (f(n+1) - f(n)) \big| \\[6pt]
&= \big| (f(n+1) - f(n)) \cdot (2 - (x-n)) \big| \\[6pt]
&= |f(n+1) - f(n)| \cdot |2 + (-(x-n))| \\[6pt]
&\underset{\triangle Ugl.}{\leq} |f(n+1) - f(n)| \cdot (|2| + |-(x-n)|) \\[6pt]
&= |f(n+1) - f(n)| \cdot (2 + |x-n|) \\[6pt]
&< |f(n+1) - f(n)| \cdot (2 + \delta) \\[6pt]
&< \varepsilon.
\end{align*}
Damit ist die Funktion auf den Intervallen $I_n = [n; n+1)$ stetig. 
Da Folgenstetigkeit und Stetigkeit auf metrischen Räumen äquivalent sind, (QUELLE) 
folgt, dass die Funktion $a(x)$ in $\mathbb{R}$ stetig ist. 
\end{proof}

\begin{theorem}\label{Stetigkeit}
Sei $f : A \to \mathbb{R}$ mit $A \subseteq \mathbb{R}$ und $g : A \to \mathbb{R}$ mit $A \subseteq \mathbb{R}$ 
eine stetige Funktion. Dann ist $f \cdot g$ auch stetig.
\end{theorem}

\begin{proof}

\[
\forall y \in A \;\; \forall \varepsilon_0 > 0 \;\; \exists \delta > 0 \;\; 
\text{dann gilt für } |x-y| < \delta_1 : |f(x) - f(y)| < \varepsilon_1
\]

\[
\forall y \in A \;\; \forall \varepsilon_0 > 0 \;\; \exists \delta > 0 \;\; 
\text{dann gilt für } |x-y| < \delta_2 : |g(x) - g(y)| < \varepsilon_2
\]

\begin{align*}
|(f \cdot g)(x) - (f \cdot g)(y)| 
&= | f(x) g(x) - f(y) g(y) | \\[2mm]
&= | f(x) g(x) - f(x) g(y) + f(x) g(y) - f(y) g(y) | \\[2mm]
&= | f(x) \cdot (g(x) - g(y)) + (f(x) - f(y)) \cdot g(y) | \\[2mm]
&\leq | f(x) \cdot (g(x) - g(y)) | + | g(y) \cdot (f(x) - f(y)) | \\[2mm]
\makebox[0pt][l]{\hspace{-2em}für $\inf\{\delta_1, \delta_2\}$ klein genug} \\[2mm]
&< | f(x) | \cdot \varepsilon + | g(y) | \cdot \varepsilon  \\[2mm]
& = \varepsilon \cdot (|f(x)| + |g(y)|).
\end{align*}

Wähle $\inf\{\delta_1, \delta_2\}$ klein genug, sodass 
\[
\vert \varepsilon \vert = \frac{\varepsilon_0}{F + G} \quad,
\text{mit }
F := \sup \{ |f(x)| \mid x \in A \}, 
\text{ und }
G := \sup \{ |g(x)| \mid x \in A \}.
\]

Dann gilt $\quad |(f \cdot g)(x) - (f \cdot g)(y)| \leq \varepsilon_0.$ Somit ist für 
$\vert x-y \vert < \inf\{\delta_1, \delta_2\} \\ \vert(f\cdot g)(x) - (f\cdot g)(y)\vert < \varepsilon_0$. 
Somit ist das Produkt zweier stetiger Funktionen stetig. 


\end{proof}

\begin{theorem}
Die Funktion 
\[
z(x) =
\begin{cases}
f(x)\cdot e^{-i\omega x} & \text{für } x \in \mathbb{Z}, \\[6pt]
e^{-i\omega \lceil x\rceil} \cdot \bigl( f(\lfloor x \rfloor) - e^{i\omega \lfloor x \rfloor} f(\lfloor x \rfloor)(x - \lfloor x \rfloor) \bigr) \cdot e^{-i\omega \lceil x\rceil} & \text{für } x \notin \mathbb{Z}
\end{cases}
\]
ist eine Regelfunktion
\end{theorem}
\begin{proof}
Sei \((c_n(x))_{n \in \mathbb{N}} := \underset{y \in \bigl[x,\, x + \tfrac{1}{n}\bigr)}{\inf} \{z(y)\}\).
Dann ist 
\[
I_n = \bigl[ x,\, x + \tfrac{1}{n} \bigr)
\]
eine Intervallschachtelung. Denn \( I_{n+1} \subset I_n \), und sei \(\varepsilon > 0\).  
Sei \( n > \varepsilon \), dann ist
\[
|I_n| = b_n - a_n = \left| x + \tfrac{1}{n} - x \right| = \left| \tfrac{1}{n} \right| < \varepsilon.
\]

Dadurch, dass \( I_n \) eine Intervallschachtelung ist, gilt:
\[
\lim_{n \to \infty} a_n = \lim_{n \to \infty} b_n = x.
\]

Also ist
\[
\sup_{x \in \mathbb{R}} \left| \inf_{y \in I_n} z(y) - z(x) \right| 
\;\xrightarrow[n \to \infty]{}\;
\sup_{x \in \mathbb{R}} \left| \inf \{z(x)\}- z(x) \right|
= \sup_{x \in \mathbb{R}} \left| z(x) - z(x) \right| 
= 0.
\]

\medskip

Somit ist die Funktionenfolge \(c_n\) gleichmäßig stetig mit \(z(x)\).  
Zudem wurden alle Funktionen der Funktionenfolge \(c_n\) so deklariert, 
dass sie Treppenfunktionen sind. Das bedeutet: es gibt eine Funktionenfolge an 
Treppenfunktionen, welche gleichmäßig stetig bezüglich \(z(x)\) ist, und somit 
ist \(z(x)\) eine Regelfunktion.

\end{proof}

\subsection{Bedeutung im größeren Kontext}
        

                
                
\section{Fazit und Ausblick}
\subsection{Zusammenfassung der Ergebnisse}
\subsection{Ausblick: Erweiterungen und Anwendungen}
                
\end{document}
                